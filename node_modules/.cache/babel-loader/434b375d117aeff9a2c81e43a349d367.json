{"ast":null,"code":"import { MAX_ROWS, MAX_COLS, MINES } from \"../constants\";\nimport { cellState } from \"../types\";\nimport { cellValue } from \"../types\";\n// Function to generate cells\nexport const generateCells = () => {\n  const cells = [];\n\n  for (let i = 0; i < MAX_ROWS; i++) {\n    cells.push([]);\n\n    for (let j = 0; j < MAX_COLS; j++) {\n      cells[i].push({\n        value: cellValue.empty,\n        state: cellState.open\n      });\n    }\n  }\n\n  let placedMines = 0;\n\n  while (placedMines < MINES) {\n    let row = Math.floor(Math.random() * MAX_ROWS);\n    let col = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][col];\n\n    if (currentCell.value != cellValue.bomb) {\n      placedMines++;\n      cells = cells.map((row, rowIndex) => cells.map((col, colIndex) => {\n        if (row == rowIndex && col == colIndex) {}\n      }));\n    }\n  }\n\n  return cells;\n};","map":{"version":3,"sources":["/Users/Matt/Desktop/Minesweeper/minesweeper/src/utils/index.ts"],"names":["MAX_ROWS","MAX_COLS","MINES","cellState","cellValue","generateCells","cells","i","push","j","value","empty","state","open","placedMines","row","Math","floor","random","col","currentCell","randomRow","bomb","map","rowIndex","colIndex"],"mappings":"AAAA,SAAQA,QAAR,EAAiBC,QAAjB,EAA2BC,KAA3B,QAAuC,cAAvC;AACA,SAAQC,SAAR,QAAwB,UAAxB;AACA,SAAQC,SAAR,QAAwB,UAAxB;AAGA;AACA,OAAO,MAAMC,aAAa,GAAG,MAAK;AAC9B,QAAMC,KAAe,GAAG,EAAxB;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGP,QAAnB,EAA6BO,CAAC,EAA9B,EAAiC;AAC7BD,IAAAA,KAAK,CAACE,IAAN,CAAW,EAAX;;AACA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGR,QAAnB,EAA6BQ,CAAC,EAA9B,EAAiC;AAC7BH,MAAAA,KAAK,CAACC,CAAD,CAAL,CAASC,IAAT,CAAc;AACVE,QAAAA,KAAK,EAAEN,SAAS,CAACO,KADP;AAEVC,QAAAA,KAAK,EAAET,SAAS,CAACU;AAFP,OAAd;AAIH;AACJ;;AAED,MAAIC,WAAW,GAAG,CAAlB;;AACA,SAAMA,WAAW,GAAGZ,KAApB,EAA0B;AACtB,QAAIa,GAAG,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBlB,QAA3B,CAAV;AACA,QAAImB,GAAG,GAAGH,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBjB,QAA3B,CAAV;AACA,UAAMmB,WAAW,GAAGd,KAAK,CAACe,SAAD,CAAL,CAAiBF,GAAjB,CAApB;;AACA,QAAGC,WAAW,CAACV,KAAZ,IAAqBN,SAAS,CAACkB,IAAlC,EAAuC;AACnCR,MAAAA,WAAW;AACXR,MAAAA,KAAK,GAAGA,KAAK,CAACiB,GAAN,CAAU,CAACR,GAAD,EAAMS,QAAN,KAAmBlB,KAAK,CAACiB,GAAN,CAAU,CAACJ,GAAD,EAAMM,QAAN,KAAmB;AAC9D,YAAGV,GAAG,IAAIS,QAAP,IAAmBL,GAAG,IAAIM,QAA7B,EAAsC,CAErC;AACJ,OAJoC,CAA7B,CAAR;AAKH;AAEJ;;AAED,SAAOnB,KAAP;AACH,CA7BM","sourcesContent":["import {MAX_ROWS,MAX_COLS, MINES} from \"../constants\"\nimport {cellState} from \"../types\"\nimport {cellValue} from \"../types\"\nimport {cell} from \"../types\"\n\n// Function to generate cells\nexport const generateCells = () =>{\n    const cells: cell[][] = [];\n    for(let i = 0; i < MAX_ROWS; i++){\n        cells.push([]);\n        for(let j = 0; j < MAX_COLS; j++){\n            cells[i].push({\n                value: cellValue.empty,\n                state: cellState.open\n            })\n        }\n    }\n\n    let placedMines = 0;\n    while(placedMines < MINES){\n        let row = Math.floor(Math.random() * MAX_ROWS);\n        let col = Math.floor(Math.random() * MAX_COLS);\n        const currentCell = cells[randomRow][col];\n        if(currentCell.value != cellValue.bomb){\n            placedMines++;\n            cells = cells.map((row, rowIndex) => cells.map((col, colIndex) => {\n                if(row == rowIndex && col == colIndex){\n\n                }\n            }));\n        }\n\n    }\n\n    return cells;\n}\n\n"]},"metadata":{},"sourceType":"module"}