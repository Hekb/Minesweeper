{"ast":null,"code":"import { MAX_ROWS, MAX_COLS, MINES } from \"../constants\";\nimport { cellState } from \"../types\";\nimport { cellValue } from \"../types\";\n// Function to generate cells\nexport const generateCells = () => {\n  let cells = [];\n\n  for (let i = 0; i < MAX_ROWS; i++) {\n    cells.push([]);\n\n    for (let j = 0; j < MAX_COLS; j++) {\n      cells[i].push({\n        value: cellValue.empty,\n        state: cellState.visible\n      });\n    }\n  }\n\n  let placedMines = 0;\n\n  while (placedMines < MINES) {\n    let randomRow = Math.floor(Math.random() * MAX_ROWS);\n    let randomCol = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][randomCol];\n\n    if (currentCell.value != cellValue.bomb) {\n      cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n        if (randomRow == rowIndex && randomCol == colIndex) {\n          return { ...cell,\n            value: cellValue.bomb\n          };\n        }\n\n        return cell;\n      }));\n      placedMines++;\n    }\n  } //generate adj number cells\n\n\n  for (let rowIndex = 0; rowIndex < MAX_ROWS; rowIndex++) {\n    for (let colIndex = 0; colIndex < MAX_COLS; colIndex++) {\n      const currentCell = cells[rowIndex][colIndex];\n\n      if (currentCell.value == cellValue.bomb) {\n        continue;\n      }\n\n      let adjBombs = 0;\n      const topLeft = rowIndex > 0 && colIndex > 0 ? cells[rowIndex - 1][colIndex - 1] : null;\n      const top = rowIndex > 0;\n    }\n  }\n\n  return cells;\n};","map":{"version":3,"sources":["/Users/Matt/Desktop/Minesweeper/minesweeper/src/utils/index.ts"],"names":["MAX_ROWS","MAX_COLS","MINES","cellState","cellValue","generateCells","cells","i","push","j","value","empty","state","visible","placedMines","randomRow","Math","floor","random","randomCol","currentCell","bomb","map","row","rowIndex","cell","colIndex","adjBombs","topLeft","top"],"mappings":"AAAA,SAAQA,QAAR,EAAiBC,QAAjB,EAA2BC,KAA3B,QAAuC,cAAvC;AACA,SAAQC,SAAR,QAAwB,UAAxB;AACA,SAAQC,SAAR,QAAwB,UAAxB;AAGA;AACA,OAAO,MAAMC,aAAa,GAAG,MAAK;AAC9B,MAAIC,KAAe,GAAG,EAAtB;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGP,QAAnB,EAA6BO,CAAC,EAA9B,EAAiC;AAC7BD,IAAAA,KAAK,CAACE,IAAN,CAAW,EAAX;;AACA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGR,QAAnB,EAA6BQ,CAAC,EAA9B,EAAiC;AAC7BH,MAAAA,KAAK,CAACC,CAAD,CAAL,CAASC,IAAT,CAAc;AACVE,QAAAA,KAAK,EAAEN,SAAS,CAACO,KADP;AAEVC,QAAAA,KAAK,EAAET,SAAS,CAACU;AAFP,OAAd;AAIH;AACJ;;AAED,MAAIC,WAAW,GAAG,CAAlB;;AACA,SAAMA,WAAW,GAAGZ,KAApB,EAA0B;AACtB,QAAIa,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBlB,QAA3B,CAAhB;AACA,QAAImB,SAAS,GAAGH,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBjB,QAA3B,CAAhB;AACA,UAAMmB,WAAW,GAAGd,KAAK,CAACS,SAAD,CAAL,CAAiBI,SAAjB,CAApB;;AACA,QAAGC,WAAW,CAACV,KAAZ,IAAqBN,SAAS,CAACiB,IAAlC,EAAuC;AACnCf,MAAAA,KAAK,GAAGA,KAAK,CAACgB,GAAN,CAAU,CAACC,GAAD,EAAMC,QAAN,KAAmBD,GAAG,CAACD,GAAJ,CAAQ,CAACG,IAAD,EAAOC,QAAP,KAAoB;AAC7D,YAAGX,SAAS,IAAIS,QAAb,IAAyBL,SAAS,IAAIO,QAAzC,EAAkD;AAC9C,iBAAO,EACH,GAAID,IADD;AAEHf,YAAAA,KAAK,EAAEN,SAAS,CAACiB;AAFd,WAAP;AAIH;;AACD,eAAOI,IAAP;AACH,OARoC,CAA7B,CAAR;AASAX,MAAAA,WAAW;AAEd;AACJ,GA9B6B,CA+B9B;;;AACA,OAAI,IAAIU,QAAQ,GAAG,CAAnB,EAAsBA,QAAQ,GAAGxB,QAAjC,EAA2CwB,QAAQ,EAAnD,EAAsD;AAClD,SAAI,IAAIE,QAAQ,GAAG,CAAnB,EAAsBA,QAAQ,GAAGzB,QAAjC,EAA2CyB,QAAQ,EAAnD,EAAsD;AAClD,YAAMN,WAAW,GAAGd,KAAK,CAACkB,QAAD,CAAL,CAAgBE,QAAhB,CAApB;;AACA,UAAGN,WAAW,CAACV,KAAZ,IAAqBN,SAAS,CAACiB,IAAlC,EAAuC;AACnC;AACH;;AACD,UAAIM,QAAQ,GAAG,CAAf;AACA,YAAMC,OAAO,GAAGJ,QAAQ,GAAG,CAAX,IAAgBE,QAAQ,GAAG,CAA3B,GAA+BpB,KAAK,CAACkB,QAAQ,GAAC,CAAV,CAAL,CAAkBE,QAAQ,GAAC,CAA3B,CAA/B,GAA+D,IAA/E;AACA,YAAMG,GAAG,GAAGL,QAAQ,GAAG,CAAvB;AACH;AACJ;;AAED,SAAOlB,KAAP;AACH,CA7CM","sourcesContent":["import {MAX_ROWS,MAX_COLS, MINES} from \"../constants\"\nimport {cellState} from \"../types\"\nimport {cellValue} from \"../types\"\nimport {cell} from \"../types\"\n\n// Function to generate cells\nexport const generateCells = () =>{\n    let cells: cell[][] = [];\n    for(let i = 0; i < MAX_ROWS; i++){\n        cells.push([]);\n        for(let j = 0; j < MAX_COLS; j++){\n            cells[i].push({\n                value: cellValue.empty,\n                state: cellState.visible\n            })\n        }\n    }\n\n    let placedMines = 0;\n    while(placedMines < MINES){\n        let randomRow = Math.floor(Math.random() * MAX_ROWS);\n        let randomCol = Math.floor(Math.random() * MAX_COLS);\n        const currentCell = cells[randomRow][randomCol];\n        if(currentCell.value != cellValue.bomb){\n            cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n                if(randomRow == rowIndex && randomCol == colIndex){\n                    return {\n                        ... cell,\n                        value: cellValue.bomb\n                    };\n                }\n                return cell;\n            }));\n            placedMines++;\n            \n        }\n    }\n    //generate adj number cells\n    for(let rowIndex = 0; rowIndex < MAX_ROWS; rowIndex++){\n        for(let colIndex = 0; colIndex < MAX_COLS; colIndex++){\n            const currentCell = cells[rowIndex][colIndex];\n            if(currentCell.value == cellValue.bomb){\n                continue;\n            }\n            let adjBombs = 0;\n            const topLeft = rowIndex > 0 && colIndex > 0 ? cells[rowIndex-1][colIndex-1] : null;\n            const top = rowIndex > 0 \n        }\n    }\n    \n    return cells;\n}\n\n\n"]},"metadata":{},"sourceType":"module"}