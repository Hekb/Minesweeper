{"ast":null,"code":"import { MAX_ROWS, MAX_COLS, MINES } from \"../constants\";\nimport { cellState } from \"../types\";\nimport { cellValue } from \"../types\";\n// Function to generate cells\nexport const generateCells = () => {\n  let cells = [];\n\n  for (let i = 0; i < MAX_ROWS; i++) {\n    cells.push([]);\n\n    for (let j = 0; j < MAX_COLS; j++) {\n      cells[i].push({\n        value: cellValue.empty,\n        state: cellState.visible\n      });\n    }\n  }\n\n  let placedMines = 0;\n\n  while (placedMines < MINES) {\n    let randomRow = Math.floor(Math.random() * MAX_ROWS);\n    let randomCol = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][randomCol];\n\n    if (currentCell.value != cellValue.bomb) {\n      cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n        if (randomRow == rowIndex && randomCol == colIndex) {\n          return { ...cell,\n            value: cellValue.bomb\n          };\n        }\n\n        return cell;\n      }));\n      placedMines++;\n    }\n  } //generate adj number cells\n\n\n  for (let rowIndex2 = 0; rowIndex2 < MAX_ROWS; rowIndex2++) {\n    for (let colIndex2 = 0; colIndex2 < MAX_COLS; colIndex2++) {\n      const currentCell = cells[rowIndex2][colIndex2];\n\n      if (currentCell.value == cellValue.bomb) {\n        continue;\n      }\n\n      let adjBombs = 0;\n      const topLeft = rowIndex2 > 0 && colIndex2 > 0 ? cells[rowIndex2 - 1][colIndex2 - 1] : null;\n      const top = rowIndex2 > 0 ? cells[rowIndex2 - 1][colIndex2] : null;\n      const topRight = rowIndex2 > 0 && colIndex2 < MAX_COLS - 1 ? cells[rowIndex2 - 1][colIndex2 + 1] : null;\n      const left = colIndex2 > 0 ? cells[rowIndex2][colIndex2 - 1] : null;\n      const right = colIndex2 < MAX_COLS - 1 ? cells[rowIndex2][colIndex2 + 1] : null;\n      const bottomLeft = rowIndex2 < MAX_ROWS - 1 && colIndex2 > 0 ? cells[rowIndex2 + 1][colIndex2 - 1] : null;\n      const bottom = rowIndex2 < MAX_ROWS - 1 ? cells[rowIndex2 + 1][colIndex2] : null;\n      const bottomRight = rowIndex2 < MAX_ROWS - 1 && colIndex2 < MAX_COLS - 1 ? cells[rowIndex2 + 1][colIndex2 + 1] : null;\n\n      if ((topLeft === null || topLeft === void 0 ? void 0 : topLeft.value) === cellValue.bomb) {\n        adjBombs++;\n      }\n    }\n  }\n\n  return cells;\n};","map":{"version":3,"sources":["/Users/Matt/Desktop/Minesweeper/minesweeper/src/utils/index.ts"],"names":["MAX_ROWS","MAX_COLS","MINES","cellState","cellValue","generateCells","cells","i","push","j","value","empty","state","visible","placedMines","randomRow","Math","floor","random","randomCol","currentCell","bomb","map","row","rowIndex","cell","colIndex","rowIndex2","colIndex2","adjBombs","topLeft","top","topRight","left","right","bottomLeft","bottom","bottomRight"],"mappings":"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","sourcesContent":["import {MAX_ROWS,MAX_COLS, MINES} from \"../constants\"\nimport {cellState} from \"../types\"\nimport {cellValue} from \"../types\"\nimport {cell} from \"../types\"\n\n// Function to generate cells\nexport const generateCells = () =>{\n    let cells: cell[][] = [];\n    for(let i = 0; i < MAX_ROWS; i++){\n        cells.push([]);\n        for(let j = 0; j < MAX_COLS; j++){\n            cells[i].push({\n                value: cellValue.empty,\n                state: cellState.visible\n            })\n        }\n    }\n\n    let placedMines = 0;\n    while(placedMines < MINES){\n        let randomRow = Math.floor(Math.random() * MAX_ROWS);\n        let randomCol = Math.floor(Math.random() * MAX_COLS);\n        const currentCell = cells[randomRow][randomCol];\n        if(currentCell.value != cellValue.bomb){\n            cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n                if(randomRow == rowIndex && randomCol == colIndex){\n                    return {\n                        ... cell,\n                        value: cellValue.bomb\n                    };\n                }\n                return cell;\n            }));\n            placedMines++;\n            \n        }\n    }\n    //generate adj number cells\n    for(let rowIndex2 = 0; rowIndex2 < MAX_ROWS; rowIndex2++){\n        for(let colIndex2= 0; colIndex2 < MAX_COLS; colIndex2++){\n            const currentCell = cells[rowIndex2][colIndex2];\n            if(currentCell.value == cellValue.bomb){\n                continue;\n            }\n            let adjBombs = 0;\n            const topLeft = rowIndex2 > 0 && colIndex2 > 0 ? cells[rowIndex2-1][colIndex2-1] : null;\n            const top = rowIndex2 > 0 ? cells[rowIndex2-1][colIndex2] : null;\n            const topRight = rowIndex2 > 0 && colIndex2 < MAX_COLS - 1 ? cells[rowIndex2-1][colIndex2+1]: null;\n            const left = colIndex2 > 0 ? cells[rowIndex2][colIndex2 - 1]: null;\n            const right = colIndex2 < MAX_COLS - 1 ? cells[rowIndex2][colIndex2+1]: null;\n            const bottomLeft = rowIndex2 < MAX_ROWS - 1 && colIndex2 > 0 ? cells[rowIndex2+1][colIndex2-1]: null;\n            const bottom = rowIndex2 < MAX_ROWS - 1 ? cells[rowIndex2+1][colIndex2]: null;\n            const bottomRight = rowIndex2 < MAX_ROWS - 1 && colIndex2 < MAX_COLS - 1 ? cells[rowIndex2+1][colIndex2+1]: null;\n            \n            if(topLeft?.value === cellValue.bomb){\n                adjBombs++;\n            }\n        }   \n    }\n    \n    return cells;\n}\n\n\n"]},"metadata":{},"sourceType":"module"}